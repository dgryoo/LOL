@ Refactoring

Gamer 클래스 리팩토링완료 Gamer -> gamePlay.Team

@ 인터페이스

- inter.Attackable attack(absclass.Thing thing)
- inter.Revivable revive()
- inter.Movable move(int direction)
- inter.Skillable( 최하위 객체에서 오버라이딩 )

@ 추상클래스

- Athing extends absclass.Thing implements inter.Attackable - TurretTower
- Rthing extends absclass.Thing implements inter.Revivable - SuppressTower
- Sthing extends absclass.Thing implements inter.Skillable - CommandTower
- absclass.AttackableMovableThing extends absclass.AttackableThing implements inter.Movable - Minion
- absclass.AttackableRevivableThing extends absclass.AttackableThing implements inter.Revivable - 없음
- ARSTHing extends ARTHing implements inter.Skillable - Dragon
- absclass.AttackableRevivableMovableThing extends absclass.AttackableRevivableThing implements inter.Movable - Wolf
- absclass.AttackableRevivableMovableSkillableThing extends absclass.AttackableRevivableMovableThing implements inter.Skillable - unit.hero, Golem

A <- AM
  <- AR <- ARS <- ARMS
        <- ARM
R

S

@ 클래스

- CommandTower extends Sthing
    본진타워 터지면 게임끝남

- SuppressTower extends Rthing
    죽었을시에 CommandTower에서 슈퍼미니언이 생성됨 일정시간 후 부활

- TurretTower extends AThing
    공격가능한 타워

- Minion extends absclass.AttackableMovableThing
    CommandTower에서 생성하는 쫄따구

- unit.hero extends absclass.AttackableRevivableMovableSkillableThing
    영웅을 싱글톤으로 하나만 생성하는기능 추가

- Wolf extends absclass.AttackableRevivableMovableThing
    스킬 못쓰는 중립 몬스터

- Golem extends ARMSTHing
    스킬쓰는 중립 몬스터

- Dragon extends absclass.AttackableRevivableSkillableThing
    보스중립몬스터 움직이지 못함


@ 만들어야 할 것

* inter.Skill 구현
    - SkillAttackedable 인터페이스를 만들어서 SkillAttack

* 팀별 객체들을 어떻게 할지 BLUE/RED팀 Set? 해서 Gamer, TowerList, Minion List 추가? (2)
    - gamePlay.Team 클래스를 만들어서 HeroList, MinionList, Tower등을 변수로 가지게끔 (x 불가능)


* TurretTower, Minion, Creep AutoAttack (2)
    - TurretTower, Minion, Creep은 attackRange에 들어오면 자동공격하도록 설정
      game에 Hero들이 턴을 마친 후 attackCheck(List, List) {Gamer.HeroList 를 받아서 attackRange안에 있는지 검증 후 공격
      여러명이 있을 때 가장 가까운 Hero를 공격}

* main의 다음 코드를 exception으로 처리? try catch 로 처리? (2)
 if (target >= 1 && target <= defendGamer.getHeroList().size()) {
                              recentHero.attack(defendGamer.getHeroList().get(target - 1));
                              break;
                          } else {
                              System.out.println("공격대상을 다시 지정해 주세요.");
                          }

@ 완료한 것

* Revive 인터페이스를 어떻게 구현 할 것 인가 (1) RevivableManager를 통해 해결함 (싱글톤, 옵저버패턴 적용)
    - gamer의 heroList에서 빼서 deadMap<key : Thing, value : List>에 추가했다가 살린다.
      RThing에 int reviveStack, int reviveValue (객체마다 reviveValue를 다르게 할 예정) 을 추가해서
      Stack == Value 가 되었을때 부활한다. 게임 while문 마지막에 배치시켜 턴이 끝났을때 부활하도록 함.
      deadMap에 들어갔을때 deadMap에 있는 객체의 reviveTurn을 턴마다 1씩 증가
      plusReviveTurn() {reviveValue++;}
      revive(gamePlay.Team team) {if (reviveStack == reviveValue) {sout("부활")} }
      game에서 마지막에 매턴마다 deadList에서 위에 해당하는게 있는지 확인 후 부활시킨 후 value에 key를 추가시킨다.
      - RTHing에 말고 Game에 생성

    - Rthing에 boolean live 를 추가하여 여러 list를 불러올 때 live변수를 사용하여 불러온다.
      문제점 : 2까지만 보여줬는데도 3을 누르게 되면 객체를 사용 할 수 있게됨.
      해결방안 : live = false; 일때 객체를 사용하게되면 거부하는 알고리즘 생성.


* Gamer가 영웅선택시에 이미 선택된 영웅이 또 선택되지 않도록 (1)

    - Hero를 SingleTone 객체로 생성해도 의미가 없음
    - Map<String, unit.hero> HeroSelectMap을 만들어서 ("Ash", Ash instance)로 저장
      문제점 : Hero는 new 할때 변수 gamePlay.Team team을 필요로함
      해결방안 : 1. 우선 new unit.hero(gamePlay.Team.NEUTRAL)로 생성 후 setTeam(Gamer.getTeam())으로 Team을 변경
                2. 갈아엎는다.

@ issue

* 공격 후 공격한 영웅의 skill()이 호출되는 현상 (해결완료)
    - switch case 문의 break 추가

* Hero의 공격력이 0로 되는현상 (해결완료)
    - Hero부터 생성자에서 변수의 위치가 바뀌는 현상이 발생했음

* Thing이 attacked() 할때 health가 피해의 2배로 깎이는 현상 (해결완료)
    - if문을 썼는데 앞에 if문전에 health가 깎이게 해놓고 if문 안에 또썼음

@ 개선사항

CommandTower에서 victory라는 변수로 게임의 승리, 패배 게임종료를 하게 되는데 Game에서 구현을 해야하는게 맞지않나? (미진행)

@ question

    - 실제로 롤은 턴제 게임이 아닌 실시간으로 움직이는데 원리가 Thread를 나눠서 동시에 돌아가도록 하는 것인가?
      Thread에서 순위를 정할 수 있는 것으로 알고 있는데 이상하게 상점을 켰다가 끄면 성능이 좋지 않은 컴퓨터에서는 상점끌때 렉이 걸림
      Thread에서 우선순위가 높은 동작들을 먼저 처리하고 상점을 끄고 키는것을 맨마지막에 처리하나?

@수업내용 CommandQuerySeperation 명령과 조회를 다르게하는 것
    toString 오버라이드 Thing 참고
